/***********************************************************************/
/* Open Visualization Data Explorer                                    */
/* (C) Copyright IBM Corp. 1989,1999                                   */
/* ALL RIGHTS RESERVED                                                 */
/* This code licensed under the                                        */
/*    "IBM PUBLIC LICENSE - Open Visualization Data Explorer"          */
/***********************************************************************/

#include <dxconfig.h>
#include "defines.h"



#ifndef _Node_h
#define _Node_h

#include <stdio.h> 

#include "enums.h"
#include "Base.h"
#include "List.h"
#include "SymbolManager.h"
#include "DXPacketIF.h"
#include "NodeDefinition.h" 
#include "DXType.h"
#include "SIAllocatorDictionary.h"
#include "CDBAllocatorDictionary.h"
#include "Cacheability.h"
#if WORKSPACE_PAGES
#include "GroupedObject.h"
#endif

//
// Class name definition:
//
#define ClassNode	"Node"

//
// Referenced classes:
//
class Ark;
class List;
class NodeDefinition;
class DXPacketIF;
class DXWindow;
class Parameter;
class Network;
class StandIn;
class ConfigurationDialog;

#if WORKSPACE_PAGES
class GroupRecord;
class GroupManager;
#endif

typedef long NodeStatusChange;		// For the enums below
typedef long NodeParameterStatusChange; // For the enums below

#define FOR_EACH_NODE_INPUT(node, param, iterator) \
for ( iterator.setList(node->inputParameters) ; \
     (param = (Parameter*)iterator.getNext()) ; )

#define FOR_EACH_NODE_OUTPUT(node, param, iterator) \
for ( iterator.setList(node->outputParameters)  ; \
     (param = (Parameter*)iterator.getNext()) ; )


//
// Node class definition:
//				
#if WORKSPACE_PAGES
class Node : public Base, public GroupedObject
#else
class Node : public Base 
#endif
{
    //friend StandIn::setNodePosition(Node *n, int x,int y);		
    friend class StandIn;	// FIXME: use the above

  private:
    //
    // Private member data:
    //

    //
    // Used only be the Network for sorting, graph analysis, etc.
    // See isMarked(), setMarked() and clearMarked().
    //
    bool	marked;

    //
    // This dispatches messages to this->execModuleMessageHandler().
    // Messages are not noticed unless this handler is installed
    // (in this->updateModuleMessageProtocol() via this->netPrintNode()).
    //
    static void ExecModuleMessageHandler(void *clientData, int id, void *line);

    // Should the executive cache the module's state. 
    Cacheability	nodeCacheability;

    // The symbol for the node label (contained in theSymbolTable).
    Symbol		labelSymbol;
   
    // The instance number, allocated from the definition. 
    int			instanceNumber;

#if WORKSPACE_PAGES
#else
    // The Group name. 
    Symbol		groupNameSymbol;
#endif
   
    // The network this node belongs to 
    Network *network;

    // Pointer into a table of definitions generated by the MDF file
    NodeDefinition	*definition;

    // Current values and definitions for inputs and outputs
    List		inputParameters;
    List		outputParameters;

    // Pointer to the UI standin for this node.
    StandIn		*standin;

    // Pointer to the UI standin for this node.
    ConfigurationDialog *cdb;	// CD box

    // Upper left-hand corner of standin for this module.
    int			vpe_xpos, vpe_ypos;

    //
    // Let the Configuration dialog box know that the parameter has changed.
    // Assumes that the node currently has a cdb.
    //
    void notifyCDBParameterChanged(Parameter *p, int index);

    //
    // Set the index'th parameter value of the parameter list given by io
    // to the given value  of type t.  if t==DXType::UndefinedType, then
    // be sure it can be assigned to one of the allowed types in the
    // ParameterDefinition.  If 'value' is NULL, then clear the value (and 
    // handle as a successful setting) and return the default type for the 
    // given parameter.
    // We you the Parameter methods to try and help certain values become
    // the given type (i.e. by adding "'s, {}'s, []'s and so on).
    // If send is true (the default), the results will be sent to the server
    // if possible.
    // If notify is true, then call ioParameterStatusChanged() with one of
    // Node::ParameterSetValueChanged and Node::ParameterValueChanged.
    // index is 1 based.
    //
    dx_Type setIOValue(List *io, int index, const char *value, 
					dx_Type t = DXType::UndefinedType,
					bool send = true,
					bool notify = true);

    // This is the same as setIOValue, but it sends the value to the
    // executive without causing an executive execution in execute on change.
    dx_Type setIOValueQuietly(List *io, int index, const char *value, 
					dx_Type t = DXType::UndefinedType);
    //
    //  Mark the given parameter as clean.
    //
    void setIODirty(List *io, int index, bool dirty);

#if WORKSPACE_PAGES
#else
    //
    // Parse the process group info.
    //
    bool netParsePgrpComment(const char* comment,
                		const char* filename, int lineno);
#endif

    //
    // Determine if the index'th parameter in the give list is connected 
    // (i.e. has an arc) to another parameter. 
    //
    bool isIOConnected(List *io, int index);

    //
    // Get the default value of the index'th parameter in the given list. 
    //
    const char *getIODefaultValueString(List *io, int index);

    //
    // Set/Get the cacheability of the index'th parameter in the given list. 
    //
    Cacheability getIOCacheability(List *io, int index);
    virtual void setIOCacheability(List *io, int index, Cacheability c);
    bool isIOCacheabilityWriteable(List *io, int index);

    //
    // Get the currently set value of the index'th parameter in the given 
    // list.  Ignores the defaulting stuff.
    //
    const char *getIOSetValueString(List *io, int index);
    //
    // Get the default value of the index'th parameter in the given list. 
    //
    bool     isIODefaulting(List *io, int index);
    //
    // Determine if the value of the index'th parameter in the given list
    // has been set, independent of whether it's defaulting or not.
    //
    bool     isIOSet(List *io, int index);
    //
    // Get the value of the index'th parameter in the given list. 
    //
    const char *getIOValueString(List *io, int index);
    //
    // Get the type of the set value of the index'th parameter in the list. 
    //
    dx_Type getIOSetValueType(List *io, int index);

    //
    // Get the name of the input as specified in the network
    // (i.e. main_Display_1_in_3)
    //
    char *getNetworkIONameString(int index, 
					bool input, char *buffer);

    //
    // Get the name of the index'th parameter in the given list. 
    // If buf is provided, then the name is placed there, otherwise a
    // new string is created for the return value which must be deleted
    // by the caller.
    //
    char *getIONameString(List *io, int index, char *buf = NULL);
    //
    // Get the description of the index'th parameter in the given list. 
    //
    const char *getIODescription(List *io, int index);

    //
    // Return a readonly list of strings that represent the types for 
    // the given parameter.
    //
    const char* const *getIOTypeStrings(List *io, int index);

    //
    // Return a readonly list of types for the given parameter.
    // The List is readonly and must not be deleted by the caller.
    //
    List *getIOTypes(List *io, int index);

    //
    // Return a readonly list of Arks for the given parameter. 
    //
public:
    const List *getIOArks(List *io, int index);

private:
    //
    // Determine if the index'th parameter from the given list has visible tab. 
    //
    bool	isIOVisible(List *io, int index);

    //
    // Set the index'th parameter from the given list to be visible.
    //
    void	setIOVisibility(List *io, int index, bool v);

    //
    // Set all unconnected, defaulting params to be either visible or not.
    //
    void	setAllIOVisibility(List *io, bool v);

    //
    // Determine if the index'th parameter from the given list is viewable 
    //
    bool	isIOViewable(List *io, int index);

    //
    // Print 'name = value'  for the index'th parameter in the given list.
    //
    char *ioValueString(List *io, int index, const char *prefix); 

    //
    // Determine if the index'th parameter in the given list is required. 
    //
    bool	isIORequired(List *io, int index);

    //
    // Determine if the given parameter list contains parameters which
    // can be exposed, implying that there are some that are hidden. 
    //
    bool hasExposableIO(List *io);
    //
    // Determine if the given parameter list contains parameters which
    // can be hidden, implying that there are some that are exposed. 
    //
    bool hasHideableIO(List *io);

    //
    // On behalf of automatic graph layout we need to store information
    // on a per-node basis.  No one outside of the layout class will
    // ever access this information, but it's natural to keep in
    // associated with the Node for fast lookup.
    // Perhaps a better way to track this information would be to make
    // Node multiply inherit from a class that represents the information.
    // I like that way of doing it however that would require an additional
    // #include inside Node.h.  Since the included .h file would be
    // changing often, that would in turn require rebuilding the world
    // very often.  Maybe after the code stabilizes I'll try that
    // approach.
    //
    Base* layout_information;

  protected:
    //
    // Protected member data:
    //

    //
    // Used as a unique identifier for this instance of this Node when  
    // installing the Module message handler.
    //
    char	*moduleMessageId;

    void setInstanceNumber(int inst) { instanceNumber = inst; }
    bool appendInput(Parameter *p) 
		{ return inputParameters.appendElement((const void*)p); }
    bool appendOutput(Parameter *p) 
		{ return outputParameters.appendElement((const void*)p); }

    //
    // Add an Ark to the index'th parameter of parameter list 'io'.
    //
    virtual bool addIOArk(List *io, int indx, Ark *a); 
    virtual bool removeIOArk(List *io, int index, Ark *a);

    bool removeInputArk(int index, Ark *a)
		{ return this->removeIOArk(&this->inputParameters, index, a); }
    bool removeOutputArk(int index, Ark *a)
		{ return this->removeIOArk(&this->outputParameters, index, a); }


    //
    // Add/remove a set of repeatable input or output parameters to the
    // this node.   An error  ocurrs if the parameter list indicated does
    // not have repeatable parameters.
    //
    virtual bool addRepeats(bool input);
    virtual bool removeRepeats(bool input);

    Parameter *getInputParameter(int i)
    {
	return (Parameter*)inputParameters.getElement(i);
    }
    Parameter *getOutputParameter(int i)
    {
	return (Parameter*)outputParameters.getElement(i);
    }

    virtual int strcatParameterNameLvalue(char *s,  Parameter *p, 
				const char *prefix, int index);
    int strcatParameterValueString(char *s,  Parameter *p, int index);

    //
    // Parse either on input or an output comment, setting the value of
    // the indicated parameter with the value and type found in the comment.
    // (Made virtual 9/95 in order to peek at comments inside SelectionNode.)
    //
    virtual bool parseIOComment(bool input, const char* comment,
                const char* filename, int lineno, bool valueOnly = false);

    //
    // These are called when a 'node' comment is found in the .net.
    //
    bool	netParseNodeComment(const char* comment, 
						const char *file, int lineno);
    //
    // These are called to parse any comments after the 'node', 'input',
    // 'output' and 'pgrp'  comments in the .net file.
    //
    virtual bool	netParseAuxComment(const char* comment, 
						const char *file, int lineno);
    //
    // Create the invocation of the script language Node call. 
    // The string that is returned should be deleted by the caller.
    //
    virtual char        *netNodeString(const char *prefix);

    //
    // Create the invocation of any script language that is
    // to occur at the beginning or end of the containing macro.
    // The string that is returned should be deleted by the caller.
    //
    virtual char        *netBeginningOfMacroNodeString(const char *prefix);
    virtual char        *netEndOfMacroNodeString(const char *prefix);

    //
    //  Put a parameter name/value ('name = value;') pair into a string if
    //  the parameter is a value.  They may return NULL if no strings are
    //  to be printed.
    //  The strings returned should be deleted by the caller.
    //
    virtual char	*inputValueString(int i, const char *prefix)
	{ return ioValueString(&this->inputParameters,i,prefix); }
    virtual char	*outputValueString(int i, const char *prefix)
	{ return ioValueString(&this->outputParameters,i,prefix); }
    virtual char	*valuesString(const char *prefix);

    //
    // Set the index'th i/o parameter to use either the default value 
    // or the assigned valued. if notify is true then call 
    // ioParameterStatusChanged() with Node::ParameterSetValueToDefaulting.
    // If there is a connection to the executive, then send the change.
    //
    void setIODefaultingStatus(int index,
				       bool input,
				       bool defaulting,
				       bool send = true,
				       bool notify = true);

    //
    // Notify anybody that needs to know that a parameter has changed its
    // value or arcs.
    //
#if 0
    virtual void ioParameterValueChanged(bool input, int index);
    virtual void ioParameterArkChanged(bool input, int index,bool added);

    void	inputParameterValueChanged(int index)
			{ this->ioParameterValueChanged(true, index); }
    void	outputParameterValueChanged(int index)
			{ this->ioParameterValueChanged(false, index); }
    void	inputParameterArkAdded(int index)
			{ this->ioParameterArkChanged(true, index, ); }
    void	inputParameterArkRemoved(int index)
			{ this->ioParameterArkChanged(true, index, false); }
    void	outputParameterArkAdded(int index)
			{ this->ioParameterArkChanged(false, index, true); }
    void	outputParameterArkRemoved(int index)
			{ this->ioParameterArkChanged(false, index, false); }
#endif
    virtual void ioParameterStatusChanged(bool input, int index, 
				NodeParameterStatusChange status);
    // notifyIo is the same as io sort of.  notifyIo adds a check to see
    // if the network is in the process of going away.  That avoids useless work.
    void notifyIoParameterStatusChanged(bool input, int index, 
				NodeParameterStatusChange status); 

    //
    // Used by netPrintNode() to print the Names of it's input and output 
    // parameters.  In the case of inputs, if the input is taking output
    // from another source (i.e it has an arc), then we print the name
    // of that output instead.
    //
    virtual char        *inputParameterNamesString(const char *varprefix,
						const char *indent = NULL);
    virtual char        *outputParameterNamesString(const char *prefix);

    //
    // Print the comment section that precedes the Node invocation. 
    //
    bool     	netPrintCommentHeader(FILE *f);
    virtual bool     printIOComment(FILE *f, bool input, int index, 
					const char *indent = NULL,
					bool valueOnly = false);
    bool     	netPrintPgrpComment(FILE *f);
    virtual bool     netPrintAuxComment(FILE *f);


    //
    // Called when a message is received from the executive after
    // this->ExecModuleMessageHandler() is registered in 
    // this->Node::netPrintNode() to receive messages for this node.  
    // The format of the message coming back is defined by the derived class.
    //
    virtual void execModuleMessageHandler(int id, const char *line);

    //
    // Update the state of message handling for a module/UI message.
    // This is called only when we send a Node's module call to the executive
    // and the node has a module messaging protocol as defined by
    // this->hasModuleMessageProtocol().
    //
    virtual void updateModuleMessageProtocol(DXPacketIF *pif);

    //
    // Return true/false, indicating whether or not we support a message 
    // protocol between the executive module that runs for this node and the
    // UI.  By default Nodes do not have message protocols.
    //
    virtual bool hasModuleMessageProtocol();

    //
    // Return true/false, indicating whether or not we expect to receive
    // a message from the UI when our module executes in the executive.
    // Be default Nodes do not expect messages.
    //
    virtual bool expectingModuleMessage();

    //
    // Returns a string that is used to register 
    // this->ExecModuleMessageHandler() when this->hasModuleMessageProtocol() 
    // return true.  This version, returns an id that is unique to this 
    // instance of this node.
    //
    // IMPORTANT: this must set this->moduleMessageId so that Node::~Node()
    //		can know the id string. 
    //
    virtual const char *getModuleMessageIdString();

    //
    // Do any work that must be done before sending the macro/network
    // that this node belongs to to the server.
    // Be default, Nodes do not have any work that needs to be done 
    // before sending.
    //
    virtual void prepareToSendNode();

    //
    // Do any work that must be done before sending the given parameter value 
    // to the server. 
    // Be default, Nodes do not have any work that needs to be done 
    // before sending parameter values.
    //
    virtual void prepareToSendValue(int index, Parameter *p);

    //
    // See if the given string is a viable label to be used as an identifier.
    // Also make sure it is not a reserved script language word.
    // Return true if ok, false otherwise and issue and error message.
    //
    bool verifyRestrictedLabel(const char *label);

    //
    // Print/parse the 'node %s[%d]:' comment.
    // Not all nodes have cfg info, but it is provided for those that do. 
    //
    bool cfgPrintNodeLeader(FILE *f);
    bool cfgParseNodeLeader(const char *comment, 
                                const char *file, int lineno);


  public:
    //
    // Constructor:
    // Node that a node should ONLY be allocated by its definition!
    //
    Node(NodeDefinition *nd, Network *net, int inst);

    //
    // Destructor:
    //
    virtual ~Node(); 

     //
     // The following are used to give notification of Node's change in
     // status.  Currently, notification is done through the Node's network. 
     // Node selection notification is handled by the StandIn for the node.
     //
     enum {	// NodeStatusChange
                NodeSelected   = 1,     // Node was just selected.
                NodeDeselected = 2      // Node was just unselected.
     };


     //
     // The following are used to give notification of Node's parameter 
     // change in status and is an argument to ioParameterStatusChanged.  
     //
#define PARAMETER_VALUE_CHANGED		0x100000
#define PARAMETER_VISIBILITY_CHANGED	0x200000
#define PARAMETER_ARC_CHANGED		0x400000
     enum {	// NodeParameterStatusChange
        ParameterValueChanged	      = PARAMETER_VALUE_CHANGED,
        ParameterSetValueChanged      = 0x000001 | PARAMETER_VALUE_CHANGED,
        ParameterSetValueToDefaulting = 0x000002 | PARAMETER_VALUE_CHANGED,
	ParameterVisibilityChanged    = PARAMETER_VISIBILITY_CHANGED,
	ParameterBecomesVisible       = 0x000003 | PARAMETER_VISIBILITY_CHANGED,
	ParameterBecomesInvisible     = 0x000004 | PARAMETER_VISIBILITY_CHANGED,
	ParameterArkChanged	      = PARAMETER_ARC_CHANGED,
	ParameterArkRemoved	      = 0x000008 | PARAMETER_ARC_CHANGED,
	ParameterArkAdded	      = 0x000010 | PARAMETER_ARC_CHANGED
     };


    
    //
    // Generate a new instance number for this node.  We notify the
    // standIn and mark the network and the node dirty.
    // The new instance number is returned.
    //
    virtual int assignNewInstanceNumber();

    //
    // Used by ONLY Network for sorting and graph analysis.
    //
    bool	isMarked()	{ return this->marked; }
    void	setMarked()	{ this->marked = true; }
    void	clearMarked()	{ this->marked = false; }


    // FIXME: these should not be public. They are called by the newNode
    // function of the NodeDefinition class.
    virtual void setDefinition(NodeDefinition *nd);
    virtual void updateDefinition();
    //
    // Build a Node's input and output parameter lists based on this
    // node definition.
    //
    bool buildParameterLists();


    //
    // Perform any additional initializations that were not performed
    // in the constrctor.  If this returns true initialization was 
    // successful, otherwise false.  If false, then it is assumed that
    // initialize() will issue the error/warning message. 
    // initialize() is called before the Node is actually added to the
    // Network.
    //
    virtual bool initialize();

    //
    // initializeAfterNodeMember() is called after initialize() but after the 
    // Node is actually added to the Network.
    //
    virtual void initializeAfterNetworkMember() {}


    // Get the name of this module
    virtual Symbol getNameSymbol() 
		{ return this->definition->getNameSymbol(); } 
    const char *getNameString() 
		//{ return (const char *) this->definition->getNameString(); } 
		{ return theSymbolManager->getSymbolString(
						this->getNameSymbol()); } 
    virtual const char *getExecModuleNameString() 
		{ return this->definition->getExecModuleNameString(); } 
    const char *getDescription()
		{ return this->definition->getDescription(); }
    NodeDefinition *getDefinition() { return this->definition; }


    // Get the label of this module. 
    virtual bool setLabelString(const char *label);
    virtual const char *getLabelString();

    int     getInputCount() { return inputParameters.getSize(); }
    int     getOutputCount() { return outputParameters.getSize(); }
    void setVpePosition(int x, int y); 


#if WORKSPACE_PAGES
#else
    //
    // Process group calls.
    //
    virtual void setGroupName(const char* name);
    const char *getGroupName();
    void addToGroup(const char *group);
#endif

    //
    // Add/remove a set of input our output parameters to the give model.
    //
    bool addInputRepeats()    { return addRepeats(true); }
    bool removeInputRepeats() { return removeRepeats(true); }
    bool addOutputRepeats()    { return addRepeats(false); }
    bool removeOutputRepeats() { return removeRepeats(false); }


    bool hasExposableInput()
		{ return this->hasExposableIO(&this->inputParameters); }
    bool hasExposableOutput()
		{ return this->hasExposableIO(&this->outputParameters); }
    bool hasHideableInput()
		{ return this->hasHideableIO(&this->inputParameters); }
    bool hasHideableOutput()
		{ return this->hasHideableIO(&this->outputParameters); }

    bool hasRemoveableInput();
    bool hasRemoveableOutput();
    bool isInputRepeatable();
    bool isOutputRepeatable();
    int	    getInputRepeatCount() { return this->definition->getInputRepeatCount(); } 
    int	    getOutputRepeatCount() { return this->definition->getOutputRepeatCount(); } 

    //
    // Get the network this node belongs to. 
    //
    Network *getNetwork() { return network; }


    //
    // Manage inputs. 
    //
    bool addInputArk(Ark *a, int index)
        { return addIOArk(&inputParameters, index, a); }
    bool addOutputArk(Ark *a, int index)
        { return addIOArk(&outputParameters, index, a); }

    const List *getInputArks(int index)
        { return getIOArks(&inputParameters, index); }
    const List *getOutputArks(int index)
        { return getIOArks(&outputParameters, index); }
    
    virtual bool deleteArk(Ark *a);

    // If these get virtualized, you must replace p->getValue() with 
    // this->getInputValueString(i) in Node.C 
    const char *getInputValueString(int index)
        { return getIOValueString(&inputParameters, index); }
    const char *getOutputValueString(int index)
        { return getIOValueString(&outputParameters, index); }
    dx_Type getInputSetValueType(int index)
        { return getIOSetValueType(&inputParameters, index); }
    dx_Type getOutputSetValueType(int index)
        { return getIOSetValueType(&outputParameters, index); }

    //
    // If buf is provided, then the name is placed there, otherwise a
    // new string is created for the return value which must be deleted
    // by the caller.
    //
    char *getInputNameString(int index, char *buf = NULL)
        { return getIONameString(&inputParameters, index, buf); }
    char *getOutputNameString(int index, char *buf = NULL)
        { return getIONameString(&outputParameters, index, buf); }

    //
    // Get the name of the input as specified in the network
    // (i.e. main_Display_1_in_3)
    // If buf is not provided the returned string must be deleted
    // by the caller.
    //
    char *getNetworkInputNameString(int index, char *buf = NULL)
        { return getNetworkIONameString(index, true, buf); }
    char *getNetworkOutputNameString(int index, char *buf = NULL)
        { return getNetworkIONameString(index, false, buf); }

    const char* const *getInputTypeStrings(int index)
        { return getIOTypeStrings(&inputParameters, index); }
    const char* const *getOutputTypeStrings(int index)
        { return getIOTypeStrings(&outputParameters, index); }

    // The List is readonly and must not be deleted by the caller.
    List* getInputTypes(int index)
        { return getIOTypes(&inputParameters, index); }
    List* getOutputTypes(int index)
        { return getIOTypes(&outputParameters, index); }

    const char *getInputDescription(int index)
        { return getIODescription(&this->inputParameters, index); }
    const char *getOutputDescription(int index)
        { return getIODescription(&this->outputParameters, index); }

    const char *getInputDefaultValueString(int index)
        { return getIODefaultValueString(&inputParameters, index); }

    const char *getInputSetValueString(int index)
        { return getIOSetValueString(&inputParameters, index); }

    bool isInputRequired(int index)
        { return isIORequired(&inputParameters, index); }
    bool isOutputRequired(int index)
        { return isIORequired(&outputParameters, index); }

    bool isInputConnected(int index)
        { return isIOConnected(&inputParameters, index); }
    bool isOutputConnected(int index)
        { return isIOConnected(&outputParameters, index); }
    bool isParameterConnected(int index, bool input)
        { return (input ? isIOConnected(&inputParameters, index) 
                        : isIOConnected(&outputParameters, index)); }

    void setInputVisibility(int index, bool v)
        { this->setIOVisibility(&inputParameters, index, v); }
    void setOutputVisibility(int index, bool v)
        { this->setIOVisibility(&outputParameters, index, v); }

    void setAllInputsVisibility(bool v)
        { this->setAllIOVisibility(&inputParameters, v); }
    void setAllOutputsVisibility(bool v)
        { this->setAllIOVisibility(&outputParameters, v); }

    void clearInputDirty(int index)
        { this->setIODirty(&inputParameters, index, false); }
    void setInputDirty(int index)
        { this->setIODirty(&inputParameters, index, true); }
    void clearOutputDirty(int index)
        { this->setIODirty(&outputParameters, index, false); }
    void setOutputDirty(int index)
        { this->setIODirty(&outputParameters, index, true); }

    bool isInputVisible(int index)
        { return isIOVisible(&inputParameters, index); }
    bool isOutputVisible(int index)
        { return isIOVisible(&outputParameters, index); }
    bool isParameterVisible(int index, bool input)
	{ return (input ? isInputVisible(index) : isOutputVisible(index)); }

    bool isInputViewable(int index)
        { return isIOViewable(&inputParameters, index); }
    bool isOutputViewable(int index)
        { return isIOViewable(&outputParameters, index); }
    bool isParameterViewable(int index, bool input)
	{ return (input ? isInputViewable(index) : isOutputViewable(index)); }

    Cacheability getOutputCacheability(int index)
	{ return this->getIOCacheability(&outputParameters, index); }
    void setOutputCacheability(int index, Cacheability c)
	{ this->setIOCacheability(&outputParameters, index, c); }
    bool isOutputCacheabilityWriteable(int index)
	{ return this->isIOCacheabilityWriteable(&outputParameters, index); }

    bool isInputDefaulting(int index)
        { return isIODefaulting(&inputParameters, index); }

    bool isInputSet(int index)
        { return isIOSet(&inputParameters, index); }

    bool hasWriteableCacheability()	
		{ return this->definition->hasWriteableCacheability(); }
    Cacheability getNodeCacheability() { return this->nodeCacheability; }
    void setNodeCacheability(Cacheability val);

    bool isParameterDefaulting(int index, int input)
        { return (input ? isIODefaulting(&inputParameters, index) 
                        : false); }

    //
    // Match output_index of this node to input_index of n.  Returns true
    // if they can connect.
    //
    virtual bool typeMatchOutputToInput(
	int output_index,
	Node *n,
	int input_index);

    //
    // Set the stored value.
    // If the parameter is not defaulting, this is
    // the same as setValue, but if it is defaulting, then we set the
    // value but leave the parameter clean and defaulting and ignore send.
    //
    virtual dx_Type setInputSetValue(int index, const char *value, 
				 dx_Type type = DXType::UndefinedType,
				 bool send = true);

    virtual dx_Type setInputValue(int index,
			       const char *value,
			       dx_Type t = DXType::UndefinedType,
			       bool send = true)
        { return setIOValue(&inputParameters, index, value, t, send); }
    virtual dx_Type setOutputValue(int index,
				const char *value,
				dx_Type t = DXType::UndefinedType,
				bool send = true)
        { return setIOValue(&outputParameters, index, value, t, send); }

    // These are the same as setInputValue and setOutputValue, but they send
    // the value to the executive without causing an executive execution in 
    // execute on change.
    virtual dx_Type setInputValueQuietly(int index,
			       const char *value,
			       dx_Type t = DXType::UndefinedType)
        { return setIOValueQuietly(&inputParameters, index, value, t); }
    virtual dx_Type setOutputValueQuietly(int index,
				const char *value,
				dx_Type t = DXType::UndefinedType)
        { return setIOValueQuietly(&outputParameters, index, value, t); }

    virtual dx_Type clearOutputValue(int index,
				  bool send = true)
        { return setIOValue(&outputParameters, 
			    index, 
			    NULL, 
			    DXType::UndefinedType, 
			    send); }

    //
    // Get this node's instance number (allocated from the definition). 
    //
    int getInstanceNumber() { return instanceNumber; }

    //
    // Get the x,y positions for the VPE
    //
    void getVpePosition(int *x, int *y);
    // FIXME: these should be removed as soon as StandIn.C uses getVpePosition()
    int getVpeX() { return this->vpe_xpos; }
    int getVpeY() { return this->vpe_ypos; }

    //
    // Parse routines for a node, called by a Network. 
    // These are called for the comments found in the .net and .cfg files
    // respectively. 
    //
    virtual bool	netParseComment(const char* comment, 
						const char *file, int lineno);
    virtual bool	cfgParseComment(const char* comment, 
						const char *file, int lineno);

    //
    // Print the stuff that belong in a .cfg file
    // At this level, there is nothing.
    //
    virtual bool     cfgPrintNode(FILE *f, PrintType destination); 

    //
    // Print the invocation of the script language Node call. 
    // LETS TALK IF YOU WANT TO MAKE THIS VIRTUAL (can you use netNodeString()).
    //
    bool     netPrintNode(FILE *f, 
			  PrintType destination, 
			  const char *prefix,
			  PacketIFCallback callback = NUL(PacketIFCallback),
			  void *clientdata = NUL(void*));

    //
    // Print the invocation of any script language that is
    // to occur at the beginning of the containing macro.
    //
    bool	netPrintBeginningOfMacroNode(FILE *f, 
			  PrintType destination, 
			  const char *prefix,
			  PacketIFCallback callback = NUL(PacketIFCallback),
			  void *clientdata = NUL(void*));

    //
    // Print the invocation of any script language that is
    // to occur at the end of the containing macro.
    //
    bool	netPrintEndOfMacroNode(FILE *f, 
			  PrintType destination, 
			  const char *prefix,
			  PacketIFCallback callback = NUL(PacketIFCallback),
			  void *clientdata = NUL(void*));

    //
    // Save any other files that relevant to this mode 
    // The name passed in is file name used to save the network (without the
    // .net extension). 
    //
    virtual bool 	auxPrintNodeFile();
    
    //
    //  Print parameter name/value ('name,name = value,value;') pairs.
    //
    virtual bool	printValues(FILE *f, const char *prefix, PrintType dest);
    //
    // For inputs, outputs or both sets of parameters send the values
    // for of which do not have arcs. 
    //  
    virtual bool     sendValues(bool     ignoreDirty = true);

    //
    // Send all dirty input and output values to the executive in the
    // quiet way using the Executive("assign noexecute",...); call.
    //
    void sendValuesQuietly();


    //
    // Manipulate the standin for this node.
    //
    StandIn *newStandIn(WorkSpace *w) 
		{ this->standin = theSIAllocatorDictionary->allocate(
					this->getNameSymbol(),w,this);
		  return this->standin; }
    StandIn *getStandIn() { return this->standin; }

    //
    // Manipulate the configration dialog box for this node.
    //
    ConfigurationDialog *newConfigurationDialog() 
		{
		    if (this->cdb == NULL)
			this->cdb = theCDBAllocatorDictionary->allocate(
					    this->getNameSymbol(),
					    this);
		    return this->cdb;
		}
    ConfigurationDialog *getConfigurationDialog() { return this->cdb; }

    //
    // Perform the default function that is associated with the 
    // StandIn's default event.
    //
    virtual void openDefaultWindow();

    //
    // Let the caller of openDefaultWindow() know what kind of window she's getting.
    // This is intended for use in EditorWindow so that we can sanity check the number
    // of cdbs were going to open before kicking off the operation and so that we
    // don't question the user before opening large numbers of interactors.
    // A name describing the type of window can be written into window_name in order
    // to enable nicer warning messages.
    //
    virtual bool defaultWindowIsCDB(char* window_name = NULL)
	{ if (window_name) strcpy (window_name, "Configuration Dialog"); return true; }

    //
    //  Open this node's configuration dialog box.
    //
    virtual void openConfigurationDialog();

    //
    //  Display help for this node in a window. 
    //
    virtual void openHelpWindow();

    //
    // Returns false for most nodes and is overridden by InteractorNode and
    // MacroNode.
    //
    virtual bool isAllowedInMacro()
    {
	return this->definition->isAllowedInMacro();
    }

    //
    // Manipulate whether the default value or assigned value is used 
    // as the value for i/o parameter i.  Parameters are indexed from 1.
    //
    void 	useDefaultInputValue(int index, bool send = true) 
			{this->setIODefaultingStatus(index,true,true,send);}
    void 	useAssignedInputValue(int index, bool send = true) 
			{this->setIODefaultingStatus(index,true,false,send);}
    void 	useDefaultOutputValue(int index, bool send = true) 
			{this->setIODefaultingStatus(index,false,true,send);}
    void 	useAssignedOutputValue(int index, bool send = true) 
			{this->setIODefaultingStatus(index,false,false,send);}

    //
    // Determine if this node is a node of the given class
    //
    bool isA(const char *classname);
    virtual bool isA(Symbol classname);

    //
    // Reset the node to using the default cfg state (probably before reading
    // in a new cfg file).  In general, the only state that should be reset
    // here is state that is saved in .cfg files.
    //
    virtual void setDefaultCfgState();

    //
    // Return true if this node has state that will be saved in a .cfg file.
    // At this level, nodes do not have cfg state.
    //
    virtual bool hasCfgState();

    //
    // Disconnect all input and output arcs from this node.
    //
    bool disconnectArks();

    //
    // Return true if the node can be switched (pasted/merged/moved) from 
    // the 'from' net to the 'to' net.
    //
    virtual bool canSwitchNetwork(Network *from, Network *to);

    //
    // Switch the node's net from 'from' to 'to'
    // 'silently' added 11/10/02 to support EditorWindow's undo.  We might be
    // merging network elements some of which are going to be discarded.  We
    // do this sometimes when we want to a node's arcs.  There are nodes saved
    // at the other ends of those arcs however those nodes are just going to
    // be thrown away at the end of the merge.
    //
    virtual void switchNetwork(Network *from, Network *to, bool silently=false);

    //
    // Get the selectable values for the n'th input.
    // This returns a pointer to a constant array of pointers to
    // constant strings which is NOT to be manipulated by the caller.
    // The returned array of pointers is NULL terminated.
    //
    const char * const *getInputValueOptions(int index);
    
    //
    // Return the window associated with this node (if one exists)
    virtual DXWindow *getDXWindow() {return NULL;}

     //
     // get the node title (if the node has a title)
     //
    virtual const char        *getTitle() {return NULL;}

#ifdef DXUI_DEVKIT
    //
    // Routines to print the module as DX C code.
    //
    bool beginDXCallModule(FILE *f);
    bool callDXCallModule(FILE *f);
    bool endDXCallModule(FILE *f);
#endif // DXUI_DEVKIT

    //
    // Provide a mechanism on behalf of StandIn for getting a small piece of text
    // for postscript output.  This text will be associated with the standin.  I
    // chose to stick this into Node rather than virtualizing the postscript
    // print func which would be the normal C++ way to handle this.  It's just that
    // postscript printing is so complicated and so few people want to learn it that
    // the benefit of making it virtual seems small.   I originally put this here
    // on behalf of Compute so that there is a way to print the expression.
    // ComputeNode will supply its expression as extra PS text.
    //
    virtual const char* getExtraPSText() { return NUL(char*); }


    //
    // I changed Network::nodeList from List to NodeList in order to provide
    // a faster lookup.  (Parsing ReceiverNodes is very slow because they
    // scan the entire network for a matching TransmitterNode.)  Some nodes
    // need special handling:  Transmitter,Receiver,Display,Image,UniqueNameNode
    // because they're frequently looked up.
    //
    virtual bool needsFastSort() { return false; }

    virtual bool printAsJava(FILE* );
    virtual const char* getJavaNodeName() { return "Node"; }
    virtual bool hasJavaRepresentation() { return false; }
    virtual bool printInputAsJava(int input) { return false; }
    virtual const char *getJavaInputValueString(int index)
        { return getInputValueString(index); }


    //
    // Java Beans
    //
    virtual bool printAsBean(FILE*) { return true; }
    virtual bool printAsBeanInitCall(FILE*) { return true; }

    //
    // On behalf of GraphLayout we store layout information on a 
    // per-node basis.  I would prefer not to have this public
    // method here because no one outside GraphLayout should ever
    // be touching the layout information.  I could declare a 
    // GraphLayout method as a friend but then I would have to
    // include another .h file here and that's really bad since
    // it would require rebuilding the world quite often.
    //
    Base* getLayoutInformation() { return this->layout_information; }
    void setLayoutInformation(Base* li);

    //
    // Returns a pointer to the class name.
    //
    virtual const char* getClassName() { return ClassNode; }
};


#endif // _Node_h
